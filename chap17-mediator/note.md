# chap17 - 中介者

调停者模式，是一种行为型模式

## 1 - 中介者的基本概念

典型存在中介者角色的场景：

1. 计算机的各个组成部分：配件插在主板上。如果没有中介者，多对多，网状关系，非常复杂。但是如果有了主板(中介者)，配件之间是星型结构
2. qq 聊天：与好友单独聊天；群聊 ---> qq 群(中介者)
3. 飞机的安全飞行 与 安全着陆：塔台(中介者)统一调度和指挥。

## 2 - 中介者模式范例的引入

在事件类驱动的软件中有比较广泛的应用，尤其是常常运用在程序的 UI 界面设计中（信号与槽）

网络游戏 登录界面，两种登录模式，单选框：

1. 游客登录。好处：不用账号密码；坏处：信息只能保存在单机
2. 账号登录。好处：可以换台电脑玩；坏处：需要账号密码

行为：

1. 选中游客登录：文本输入框是灰色的，不能输入，登录按钮白色，可以点击
2. 选中账号登录：文本输入框白色，可以输入，如果没有输入账号密码，那么登录按钮灰色，不可以被点击
3. 默认账号登录，账号登录、游客登录，有且只能二选一
4. 单击退出按钮，退出。

可见：UI 不同控件之间有复杂的联动关系。

看`s2.cxx`，这个就非常不满足 开闭原则

## 3 - 引入中介者（mediator）模式

定义：用一个中介对象（中介者）来封装一系列的对象交互。中介者使个个对象不需要显式的相互引用，
从而使其耦合松散

![uml](image.png)

但是有问题啊，如果我这样搞，这就容易造成屎山代码

中介者模式的四种角色：

1. Mediator（抽象中介者类）
2. ConcreteMediator（具体中介者类），维护了一堆 具体同事类的指针
3. colleague（抽象同事类），维护有一个指向 抽象中介类的指针
4. ConcreteColleague（具体同事类），实现了 抽象同事类 的接口

中介者模式一般用于一组对象以定义良好但复杂的方式进行通信的场合，由中介者负责控制和协调一组对象之间的交互。

当然上面这个例子也是可以使用观察者的方式改写。

优缺点：

1. 几种处理复杂的对象之间的沟通和控制，将以往 多对多 简化为 一对多
2. 将同时对象进行解耦
3. 将各种控制逻辑代码都几种（转移）到了中介者类中实现。可能会使中介者类的实现变得非常复杂甚至难以维护。
   要平衡好交互复杂度和实现复杂度。如果中介者实现的太复杂，可能会抵消掉使用该模式在其他方面带来的好处

在什么情况下考虑使用中介者模式？

1. 对象之间引用关系过于复杂，某个对象变化会导致大量其他对象的变化
2. 某个对象与大量其他对象进行连接，通信，从而造成该对象很难被复用
3. 希望将多个类（同事类）中的行为封装到一个类（中介者类）中来实现
