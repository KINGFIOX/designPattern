# chap2 - 模板方法

饭馆吃饭：点餐（粤菜、川菜） ---> 用餐（筷子、叉子） ---> 结账（现金、信用卡、微信），
因为这几个步骤都是固定的，所以作为一模板。

在固定步骤确定的情况下，通过多态机制在多个子类中对每个步骤的细节进行差异化实现，这就是模板方法模式。
模板方法模式：行为型模式。

## 一个具体实现范例的逐步重构

A 公司有一个小游戏项目组 —— 造梦西游

1. 游戏策划：简称策划，负责提出游戏的各种玩法需求，确定游戏中各种数值，比如人物（敌人）的生命值、魔法值
2. 游戏程序：简称程序，需要与游戏策划紧密配合 通过代码来实现游戏策划的各种游戏功能
3. 游戏美术：简称美术，角色设计、道具设计

游戏策划需求：游戏主角是一个战士（攻击力不高，但是生命比较多，抗揍），主角通过不断的向前走来闯关，遇到敌人就进行攻击，
敌人也会反击，敌人也会距离近时主动攻击主角。

战士：生命值 —— 1000（为 0 时主角死亡，游戏结束），魔法值 —— 0（暂时用不上，保留），攻击力 —— 200（打敌人一下，敌人失去）

```cpp
class Warrior /* 定义一个 战士类 */ {
public:
    Warrior(int life, int magic, int attack)
        : m_life(life)
        , m_magic(magic)
        , m_attack(attack)
    {
    }

private:
    int m_life; // 生命值
    int m_magic; // 魔法值
    int m_attack; // 攻击力
};
```

技能：燃烧 —— 使用该技能，可以使附近所有敌人失去 500 点生命值，但是主角自身也会损失掉 300 点生命值。

```cpp
void SKILL_Burn() /* 燃烧技能 */
{
	cout << "让所有敌人失去500点生命，相关逻辑代码这里略......" << endl;
	cout << "主角自身失去300点生命值" << endl;
	this->m_life -= 300;
	cout << "播放技能“燃烧”的技能特效给玩家看" << endl;
}
```

法师：生命值 —— 800，魔法值 200，攻击力 300
技能 “燃烧” —— 使用该技能可以是附近所有敌人失去 650 点生命值，但是主句自身会损失掉 100 点魔法值

程序开始重构，添加 战斗者父类 Fighter

与策划沟通，知道将要增加 牧师作为主角，
每个主角都有一个叫做 “燃烧” 的技能。每个主角释放 燃烧技能时 效果各不相同。
有两点肯定是不变：对主角产生影响，对敌人产生影响。

## 引入 模板方法(template method) 模式

软件开发中：需求变化是频繁的，开发人员要尝试寻找变化点，
把变化部分和稳定部分分离开来，在变化的地方应用设计模式。

学习设计模式并不难，难的是：何时何地运用设计模式。
设计模式中，往往会把成员函数说成 “算法”。

晚绑定：代码执行时才知道，执行的是哪一个虚函数

模板方法的定义：

父类中定义了一个操作中算法的骨架（稳定部分），而将一些步骤延迟到子类中去实现
（父类中定义虚函数，子类中实现/重写这个虚函数），从而达到整体稳定的而情况下能够产生一些变化的目的

设计模式的经典总结：设计模式的作用就是在变化和稳定中间寻找隔离点，分离稳定和变化，从而管理变化。

是一种代码复用技术，相当于是子类复用了父类的 SKILL_BURN。
模板方法模式，也被认为导致了一种 “反向控制结构” —— 这种结构被称为 好莱坞法则 —— 不要来调用我，我会去调用你

SKILL_BURN 是父类的 SKILL_BURN，但是 调用的确实子类的 虚函数（这也是虚函数晚绑定的能力）。

## 模板方法(template method) 模式的 uml 图

uml: unified modeling language 统一建模语言（就是一种工具，
通过该工具可以绘制一个类的结构图和 类与类 之间的关系。
这种把所有编写的代码以图形的方式呈现对于代码的全局理解和掌握的好处是巨大的）

一个类用一个长方形表示，最上面的区域是类名，中间是成员变量，下面是成员函数名。
用 public 修饰，前面用 + ；
用 protected 修饰，前面用 # ；
用 private 修饰，前面用 - ；

父类中，用 _斜体_ 来表示 虚函数；大的是稳定的，小的是变化的。箭头指向 父类

## 程序代码的进一步完善及其应用联想

```cpp
class Fighter {
public:
	void SKILL_Burn() /* 燃烧技能 */
	{
		if (canUseSKILL == false){
			return; /* 技能释放失败 */
		}
		effect_enemy(); // 对敌人产生影响
		effect_self(); // 对主角自身产生影响
		burn_play(); // 播放技能 燃烧 的技能特效
	}
private:
	virtual bool canUseSKILL() = 0;
};

bool F_MAGE::canUseSKILL() override
{
	if (this->m_magic < 100) {
		return false;
	} else {
		return true;
	}
}
```

像这里的`F_MAGE::canUseSKILL`，这个函数称之为：钩子方法，再抽象一些：子类可以控制父类行为的方法
（子类勾住父类，从而反向控制父类行为的意思）

比方说：点餐 ---> 用餐 ---(钱够)---> 付钱。
-----------------------(钱不够)---> 逃跑。

MFC 框架（微软基础类库），通过 MFC 创建一个基于对话框的应用程序。自动调用 OnInitDialog 成员函数

车间能够装配很多零件，如果零件的装配工序非常固定，工序细节有微小变化，
就可以针对精简创建一个父类，其中零件装配工序（成员函数）就非常时候采用模板方法模式来实现，
而处理某道工序的细节可以直接放在子类（针对某个零件的类）虚函数中进行
